import type { AbstractInterface } from '../device';
import { type DetailedLocateParam, type ExecutionTaskApply, type ExecutionTaskProgressOptions, Executor, type Insight, type InsightExtractOption, type InsightExtractParam, type MidsceneYamlFlowItem, type PlanningAction, type PlanningActionParamWaitFor, type PlanningLocateParam, type TMultimodalPrompt, type TUserPrompt } from '../index';
import { type IModelConfig } from '@midscene/shared/env';
import type { TaskCache } from './task-cache';
interface ExecutionResult<OutputType = any> {
    output: OutputType;
    thought?: string;
    executor: Executor;
}
export declare function locatePlanForLocate(param: string | DetailedLocateParam): PlanningAction<PlanningLocateParam>;
export declare class TaskExecutor {
    interface: AbstractInterface;
    insight: Insight;
    taskCache?: TaskCache;
    private conversationHistory;
    onTaskStartCallback?: ExecutionTaskProgressOptions['onTaskStart'];
    replanningCycleLimit?: number;
    get page(): AbstractInterface;
    constructor(interfaceInstance: AbstractInterface, insight: Insight, opts: {
        taskCache?: TaskCache;
        onTaskStart?: ExecutionTaskProgressOptions['onTaskStart'];
        replanningCycleLimit?: number;
    });
    private recordScreenshot;
    private getElementXpath;
    private prependExecutorWithScreenshot;
    convertPlanToExecutable(plans: PlanningAction[], modelConfig: IModelConfig): Promise<{
        tasks: ExecutionTaskApply<any, any, any, any>[];
    }>;
    private setupPlanningContext;
    loadYamlFlowAsPlanning(userInstruction: string, yamlString: string): Promise<{
        executor: Executor;
    }>;
    private createPlanningTask;
    runPlans(title: string, plans: PlanningAction[], modelConfig: IModelConfig): Promise<ExecutionResult>;
    private getReplanningCycleLimit;
    action(userPrompt: string, modelConfig: IModelConfig, actionContext?: string): Promise<ExecutionResult<{
        yamlFlow?: MidsceneYamlFlowItem[];
    } | undefined>>;
    private createTypeQueryTask;
    createTypeQueryExecution<T>(type: 'Query' | 'Boolean' | 'Number' | 'String' | 'Assert', demand: InsightExtractParam, modelConfig: IModelConfig, opt?: InsightExtractOption, multimodalPrompt?: TMultimodalPrompt): Promise<ExecutionResult<T>>;
    assert(assertion: TUserPrompt, modelConfig: IModelConfig, opt?: InsightExtractOption): Promise<ExecutionResult<boolean>>;
    private appendErrorPlan;
    taskForSleep(timeMs: number, modelConfig: IModelConfig): Promise<ExecutionTaskApply<any, any, any, any>>;
    waitFor(assertion: TUserPrompt, opt: PlanningActionParamWaitFor, modelConfig: IModelConfig): Promise<ExecutionResult<void>>;
}
export {};
