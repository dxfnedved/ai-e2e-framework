{"version":3,"file":"static/js/async/702.60261735.js","sources":["webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://playground/../../node_modules/.pnpm/pixi.js@8.1.1/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n"],"names":["a","Object","Map","h"],"mappings":"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"}