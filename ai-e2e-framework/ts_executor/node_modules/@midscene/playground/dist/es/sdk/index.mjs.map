{"version":3,"file":"sdk/index.mjs","sources":["webpack://@midscene/playground/./src/sdk/index.ts"],"sourcesContent":["import type { DeviceAction } from '@midscene/core';\nimport { PLAYGROUND_SERVER_PORT } from '@midscene/shared/constants';\nimport type { BasePlaygroundAdapter } from '../adapters/base';\nimport { LocalExecutionAdapter } from '../adapters/local-execution';\nimport { RemoteExecutionAdapter } from '../adapters/remote-execution';\nimport type {\n  ExecutionOptions,\n  FormValue,\n  PlaygroundAgent,\n  PlaygroundConfig,\n  ValidationResult,\n} from '../types';\n\nexport class PlaygroundSDK {\n  private adapter: BasePlaygroundAdapter;\n\n  constructor(config: PlaygroundConfig) {\n    this.adapter = this.createAdapter(\n      config.type,\n      config.serverUrl,\n      config.agent,\n    );\n  }\n\n  private createAdapter(\n    type: string,\n    serverUrl?: string,\n    agent?: PlaygroundAgent,\n  ): BasePlaygroundAdapter {\n    switch (type) {\n      case 'local-execution':\n        if (!agent) {\n          throw new Error('Agent is required for local execution');\n        }\n        return new LocalExecutionAdapter(agent);\n      case 'remote-execution': {\n        // Use provided serverUrl first, then fallback to localhost if current page origin is file:// or default\n        const finalServerUrl =\n          serverUrl ||\n          (typeof window !== 'undefined' &&\n          window.location.protocol.includes('http')\n            ? window.location.origin\n            : `http://localhost:${PLAYGROUND_SERVER_PORT}`);\n\n        return new RemoteExecutionAdapter(finalServerUrl);\n      }\n      default:\n        throw new Error(`Unsupported execution type: ${type}`);\n    }\n  }\n\n  async executeAction(\n    actionType: string,\n    value: FormValue,\n    options: ExecutionOptions,\n  ): Promise<unknown> {\n    const result = await this.adapter.executeAction(actionType, value, options);\n\n    // Stop any active polling for this request after execution completes\n    if (options.requestId) {\n      this.stopProgressPolling(options.requestId);\n    }\n\n    return result;\n  }\n\n  async getActionSpace(context?: unknown): Promise<DeviceAction<unknown>[]> {\n    // Both adapters now accept context parameter\n    // Local will prioritize internal agent, Remote will use server + fallback\n    return this.adapter.getActionSpace(context);\n  }\n\n  validateStructuredParams(\n    value: FormValue,\n    action: DeviceAction<unknown> | undefined,\n  ): ValidationResult {\n    return this.adapter.validateParams(value, action);\n  }\n\n  formatErrorMessage(error: any): string {\n    return this.adapter.formatErrorMessage(error);\n  }\n\n  createDisplayContent(\n    value: FormValue,\n    needsStructuredParams: boolean,\n    action: DeviceAction<unknown> | undefined,\n  ): string {\n    return this.adapter.createDisplayContent(\n      value,\n      needsStructuredParams,\n      action,\n    );\n  }\n\n  // Get adapter ID (works for both remote and local execution)\n  get id(): string | undefined {\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.id;\n    }\n    if (this.adapter instanceof LocalExecutionAdapter) {\n      return this.adapter.id;\n    }\n    return undefined;\n  }\n\n  // Server communication methods (for remote execution)\n  async checkStatus(): Promise<boolean> {\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.checkStatus();\n    }\n    return true; // For local execution, always return true\n  }\n\n  async overrideConfig(aiConfig: any): Promise<void> {\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.overrideConfig(aiConfig);\n    }\n    // For local execution, this is a no-op\n  }\n\n  async getTaskProgress(requestId: string): Promise<{ tip?: string }> {\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.getTaskProgress(requestId);\n    }\n    if (this.adapter instanceof LocalExecutionAdapter) {\n      return this.adapter.getTaskProgress(requestId);\n    }\n    return { tip: undefined }; // Fallback\n  }\n\n  // Cancel task (for remote execution)\n  async cancelTask(requestId: string): Promise<any> {\n    // Stop progress polling for this request\n    this.stopProgressPolling(requestId);\n\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.cancelTask(requestId);\n    }\n    return { error: 'Cancel task not supported in local execution mode' };\n  }\n\n  // Progress callback management\n  onProgressUpdate(callback: (tip: string) => void): void {\n    // Pass the callback to the adapter if it supports it\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      this.adapter.setProgressCallback(callback);\n    } else if (this.adapter instanceof LocalExecutionAdapter) {\n      this.adapter.setProgressCallback(callback);\n    }\n  }\n\n  // Start progress polling for remote execution (deprecated - now handled by adapter)\n  startProgressPolling(requestId: string): void {\n    // This method is now handled by the RemoteExecutionAdapter automatically\n    // when executeAction is called with a requestId\n    console.warn(\n      'startProgressPolling is deprecated - polling is now automatic',\n    );\n  }\n\n  // Stop progress polling for a specific request (deprecated - now handled by adapter)\n  stopProgressPolling(requestId: string): void {\n    // This method is now handled by the RemoteExecutionAdapter automatically\n    console.warn(\n      'stopProgressPolling is deprecated - polling cleanup is now automatic',\n    );\n  }\n\n  // Cancel execution - supports both remote and local\n  async cancelExecution(requestId: string): Promise<void> {\n    this.stopProgressPolling(requestId);\n\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      await this.adapter.cancelTask(requestId);\n    } else if (this.adapter instanceof LocalExecutionAdapter) {\n      // For local execution, we might need to implement agent cancellation\n      console.warn('Local execution cancellation not fully implemented');\n    }\n  }\n\n  // Screenshot method for remote execution\n  async getScreenshot(): Promise<{\n    screenshot: string;\n    timestamp: number;\n  } | null> {\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.getScreenshot();\n    }\n    return null; // For local execution, not supported yet\n  }\n\n  // Get interface information (type and description)\n  async getInterfaceInfo(): Promise<{\n    type: string;\n    description?: string;\n  } | null> {\n    if (this.adapter instanceof LocalExecutionAdapter) {\n      return this.adapter.getInterfaceInfo();\n    }\n    if (this.adapter instanceof RemoteExecutionAdapter) {\n      return this.adapter.getInterfaceInfo();\n    }\n    return null;\n  }\n}\n"],"names":["PlaygroundSDK","type","serverUrl","agent","Error","LocalExecutionAdapter","finalServerUrl","window","PLAYGROUND_SERVER_PORT","RemoteExecutionAdapter","actionType","value","options","result","context","action","error","needsStructuredParams","aiConfig","requestId","undefined","callback","console","config"],"mappings":"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"}