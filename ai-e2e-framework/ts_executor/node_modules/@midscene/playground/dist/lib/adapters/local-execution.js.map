{"version":3,"file":"adapters/local-execution.js","sources":["webpack://@midscene/playground/webpack/runtime/define_property_getters","webpack://@midscene/playground/webpack/runtime/has_own_property","webpack://@midscene/playground/webpack/runtime/make_namespace_object","webpack://@midscene/playground/./src/adapters/local-execution.ts"],"sourcesContent":["__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { DeviceAction } from '@midscene/core';\nimport { overrideAIConfig } from '@midscene/shared/env';\nimport { uuid } from '@midscene/shared/utils';\nimport { executeAction, parseStructuredParams } from '../common';\nimport type { ExecutionOptions, FormValue, PlaygroundAgent } from '../types';\nimport { BasePlaygroundAdapter } from './base';\n\nexport class LocalExecutionAdapter extends BasePlaygroundAdapter {\n  private agent: PlaygroundAgent;\n  private taskProgressTips: Record<string, string> = {};\n  private progressCallback?: (tip: string) => void;\n  private readonly _id: string; // Unique identifier for this local adapter instance\n  private currentRequestId?: string; // Track current request to prevent stale callbacks\n\n  constructor(agent: PlaygroundAgent) {\n    super();\n    this.agent = agent;\n    this._id = uuid(); // Generate unique ID for local adapter\n  }\n\n  // Get adapter ID\n  get id(): string {\n    return this._id;\n  }\n\n  setProgressCallback(callback: (tip: string) => void): void {\n    // Clear any existing callback before setting new one\n    this.progressCallback = undefined;\n    // Set the new callback\n    this.progressCallback = callback;\n  }\n\n  private cleanup(requestId: string): void {\n    delete this.taskProgressTips[requestId];\n  }\n\n  async parseStructuredParams(\n    action: DeviceAction<unknown>,\n    params: Record<string, unknown>,\n    options: ExecutionOptions,\n  ): Promise<unknown[]> {\n    // Use shared implementation from common.ts\n    return await parseStructuredParams(action, params, options);\n  }\n\n  formatErrorMessage(error: any): string {\n    const errorMessage = error?.message || '';\n    if (errorMessage.includes('of different extension')) {\n      return 'Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://midscenejs.com/quick-experience.html#faq';\n    }\n    return this.formatBasicErrorMessage(error);\n  }\n\n  // Local execution - use base implementation\n  // (inherits default executeAction from BasePlaygroundAdapter)\n\n  // Local execution gets actionSpace from internal agent (parameter is for backward compatibility)\n  async getActionSpace(context?: unknown): Promise<DeviceAction<unknown>[]> {\n    // Priority 1: Use agent's getActionSpace method\n    if (this.agent?.getActionSpace) {\n      return await this.agent.getActionSpace();\n    }\n\n    // Priority 2: Use agent's interface.actionSpace method\n    if (\n      this.agent &&\n      'interface' in this.agent &&\n      typeof this.agent.interface === 'object'\n    ) {\n      const page = this.agent.interface as {\n        actionSpace?: () => Promise<DeviceAction<unknown>[]>;\n      };\n      if (page?.actionSpace) {\n        return await page.actionSpace();\n      }\n    }\n\n    // Priority 3: Fallback to context parameter (for backward compatibility with tests)\n    if (context && typeof context === 'object' && 'actionSpace' in context) {\n      const contextPage = context as {\n        actionSpace: () => Promise<DeviceAction<unknown>[]>;\n      };\n      return await contextPage.actionSpace();\n    }\n\n    return [];\n  }\n\n  // Local execution doesn't use a server, so always return true\n  async checkStatus(): Promise<boolean> {\n    return true;\n  }\n\n  async overrideConfig(aiConfig: Record<string, unknown>): Promise<void> {\n    // For local execution, use the shared env override function\n    overrideAIConfig(aiConfig);\n  }\n\n  async executeAction(\n    actionType: string,\n    value: FormValue,\n    options: ExecutionOptions,\n  ): Promise<unknown> {\n    // Get actionSpace using our simplified getActionSpace method\n    const actionSpace = await this.getActionSpace();\n    let originalOnTaskStartTip: ((tip: string) => void) | undefined;\n\n    // Setup progress tracking if requestId is provided\n    if (options.requestId && this.agent) {\n      // Track current request ID to prevent stale callbacks\n      this.currentRequestId = options.requestId;\n      originalOnTaskStartTip = this.agent.onTaskStartTip;\n\n      // Set up a fresh callback\n      this.agent.onTaskStartTip = (tip: string) => {\n        // Only process if this is still the current request\n        if (this.currentRequestId !== options.requestId) {\n          return;\n        }\n\n        // Store tip for our progress tracking\n        this.taskProgressTips[options.requestId!] = tip;\n\n        // Call the direct progress callback set via setProgressCallback\n        if (this.progressCallback) {\n          this.progressCallback(tip);\n        }\n\n        if (typeof originalOnTaskStartTip === 'function') {\n          originalOnTaskStartTip(tip);\n        }\n      };\n    }\n\n    try {\n      // Call the base implementation with the original signature\n      const result = await executeAction(\n        this.agent,\n        actionType,\n        actionSpace,\n        value,\n        options,\n      );\n\n      // For local execution, we need to package the result with dump and reportHTML\n      // similar to how the server does it\n      const response = {\n        result,\n        dump: null as unknown,\n        reportHTML: null as string | null,\n        error: null as string | null,\n      };\n\n      try {\n        // Get dump and reportHTML from agent like the server does\n        if (this.agent.dumpDataString) {\n          const dumpString = this.agent.dumpDataString();\n          if (dumpString) {\n            response.dump = JSON.parse(dumpString);\n          }\n        }\n\n        if (this.agent.reportHTMLString) {\n          response.reportHTML = this.agent.reportHTMLString() || null;\n        }\n\n        // Write out action dumps\n        if (this.agent.writeOutActionDumps) {\n          this.agent.writeOutActionDumps();\n        }\n      } catch (error: unknown) {\n        console.error('Failed to get dump/reportHTML from agent:', error);\n      }\n\n      this.agent.resetDump();\n\n      return response;\n    } finally {\n      // Always clean up progress tracking to prevent memory leaks\n      if (options.requestId) {\n        this.cleanup(options.requestId);\n        // Clear the agent callback to prevent accumulation\n        if (this.agent) {\n          this.agent.onTaskStartTip = originalOnTaskStartTip;\n        }\n      }\n    }\n  }\n\n  async getTaskProgress(requestId: string): Promise<{ tip?: string }> {\n    // Return the stored tip for this requestId\n    return { tip: this.taskProgressTips[requestId] || undefined };\n  }\n\n  // Local execution task cancellation - minimal implementation\n  async cancelTask(\n    _requestId: string,\n  ): Promise<{ error?: string; success?: boolean }> {\n    if (!this.agent) {\n      return { error: 'No active agent found for this requestId' };\n    }\n\n    try {\n      await this.agent.destroy?.();\n      return { success: true };\n    } catch (error: unknown) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      console.error(`Failed to cancel agent: ${errorMessage}`);\n      return { error: `Failed to cancel: ${errorMessage}` };\n    }\n  }\n\n  // Get interface information from the agent\n  async getInterfaceInfo(): Promise<{\n    type: string;\n    description?: string;\n  } | null> {\n    if (!this.agent?.interface) {\n      return null;\n    }\n\n    try {\n      const type = this.agent.interface.interfaceType || 'Unknown';\n      const description = this.agent.interface.describe?.() || undefined;\n\n      return {\n        type,\n        description,\n      };\n    } catch (error: unknown) {\n      console.error('Failed to get interface info:', error);\n      return null;\n    }\n  }\n}\n"],"names":["__webpack_require__","definition","key","Object","obj","prop","Symbol","LocalExecutionAdapter","BasePlaygroundAdapter","callback","undefined","requestId","action","params","options","parseStructuredParams","error","errorMessage","context","_this_agent","page","contextPage","aiConfig","overrideAIConfig","actionType","value","actionSpace","originalOnTaskStartTip","tip","result","executeAction","response","dumpString","JSON","console","_requestId","Error","_this_agent_interface","type","description","agent","uuid"],"mappings":"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"}